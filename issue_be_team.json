{
  "title": "⚙️ [BE #176] Implement Register Metadata Sync from Firmware",
  "body": "## 🎯 **OVERVIEW**\n\n**Related to:** #176  \n**Team:** Backend Team  \n**Priority:** 🔴 Critical  \n**Estimate:** 21 hours (~3 days)  \n**Depends on:** Firmware Issue: \"Implement Register Metadata API\"\n\n### 📋 **Context**\n\nIssue #176 yêu cầu Backend có thể truy xuất register metadata (address, mode). Hiện tại:\n- ✅ Backend ĐÃ CÓ database schema (`Register` model) với address, mode, access_level\n- ✅ Backend ĐÃ CÓ CRUD APIs cho registers\n- ❌ Database RỖNG - chưa có register data\n- ❌ THIẾU mechanism để sync register metadata từ Firmware\n- ❌ THIẾU query APIs với filters (mode, access_level, module_addr)\n\n### 🎯 **Objective**\n\nImplement sync mechanism để pull register metadata từ Firmware API vào Database, và expose query APIs cho Frontend.\n\n---\n\n## 📦 **TECHNICAL ARCHITECTURE**\n\n### **Data Flow**\n\n```\n┌─────────────────────────────────────┐\n│   Frontend / Admin UI               │\n│   Trigger sync request              │\n└──────────────┬──────────────────────┘\n               │ POST /admin/registers/sync\n┌──────────────▼──────────────────────┐\n│   Backend API                       │\n│   /api/v1/admin/registers/sync      │\n└──────────────┬──────────────────────┘\n               │\n┌──────────────▼──────────────────────┐\n│   Register Sync Service             │\n│   - sync_module_registers()         │\n│   - sync_all_modules()              │\n└──────────────┬──────────────────────┘\n               │\n┌──────────────▼──────────────────────┐\n│   Unified Firmware Service          │\n│   - get_module_registers()          │\n│   - get_register_info()             │\n└──────────────┬──────────────────────┘\n               │ HTTP GET\n┌──────────────▼──────────────────────┐\n│   Firmware HTTP API                 │\n│   /api/v1/modules/{addr}/registers  │\n└──────────────┬──────────────────────┘\n               │\n┌──────────────▼──────────────────────┐\n│   Database (SQLite)                 │\n│   registers table                   │\n└─────────────────────────────────────┘\n```\n\n### **Database Schema (Already Exists)**\n\n```sql\nCREATE TABLE registers (\n    id INTEGER PRIMARY KEY AUTOINCREMENT,\n    name VARCHAR(100) NOT NULL,\n    address VARCHAR(50) NOT NULL UNIQUE,  -- e.g., \"0x0000\"\n    mode ENUM('READ', 'WRITE', 'READ_WRITE') NOT NULL,\n    access_level ENUM('USER', 'ADMIN', 'SYSTEM') NOT NULL,\n    is_safe_register BOOLEAN NOT NULL DEFAULT FALSE,\n    unit VARCHAR(20),\n    description VARCHAR(255),\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE INDEX idx_registers_address ON registers(address);\nCREATE INDEX idx_registers_mode ON registers(mode);\nCREATE INDEX idx_registers_access_level ON registers(access_level);\n```\n\n---\n\n## ✅ **TASKS BREAKDOWN**\n\n### **Task 1: Extend Firmware Integration Service** (2h)\n\n**File to modify:**\n- `backend/app/services/unified_firmware_service.py`\n\n**Methods to add:**\n\n```python\nclass UnifiedFirmwareService:\n    async def get_module_registers(self, module_addr: int) -> Dict[str, Any]:\n        \"\"\"\n        Get all registers metadata for a module from Firmware\n        \n        Args:\n            module_addr: Module address (2=Power, 3=Safety, 4=Motor, 5=Dock)\n            \n        Returns:\n            Dict with register metadata:\n            {\n                \"success\": true,\n                \"data\": {\n                    \"module_addr\": 2,\n                    \"module_name\": \"Power Module\",\n                    \"register_count\": 51,\n                    \"registers\": [\n                        {\n                            \"address\": \"0x0000\",\n                            \"mode\": \"READ\",\n                            \"data_type\": \"UINT16\",\n                            \"access_level\": \"USER\",\n                            \"is_safe_register\": false,\n                            \"unit\": \"V\",\n                            \"description\": \"Battery pack voltage\",\n                            \"min_value\": 0,\n                            \"max_value\": 65535,\n                            \"default_value\": 0\n                        },\n                        ...\n                    ]\n                }\n            }\n        \"\"\"\n        try:\n            response = await self.http_client.get(\n                f\"/api/v1/modules/{module_addr}/registers\"\n            )\n            \n            if response.status_code == 200:\n                return response.json()\n            elif response.status_code == 404:\n                return {\"success\": False, \"error\": \"Module not found\"}\n            else:\n                return {\"success\": False, \"error\": f\"HTTP {response.status_code}\"}\n                \n        except httpx.TimeoutException:\n            return {\"success\": False, \"error\": \"Timeout\"}\n        except Exception as e:\n            return {\"success\": False, \"error\": str(e)}\n    \n    async def get_register_info(self, module_addr: int, register_addr: str) -> Dict[str, Any]:\n        \"\"\"\n        Get metadata for a specific register from Firmware\n        \n        Args:\n            module_addr: Module address\n            register_addr: Register address (hex format, e.g., \"0x0000\")\n            \n        Returns:\n            Dict with single register metadata\n        \"\"\"\n        try:\n            response = await self.http_client.get(\n                f\"/api/v1/modules/{module_addr}/registers/{register_addr}\"\n            )\n            \n            if response.status_code == 200:\n                return response.json()\n            else:\n                return {\"success\": False, \"error\": f\"HTTP {response.status_code}\"}\n                \n        except Exception as e:\n            return {\"success\": False, \"error\": str(e)}\n```\n\n**Technical Requirements:**\n- Async/await pattern\n- Timeout handling (30s)\n- Error handling cho network issues\n- Logging cho debugging\n- Type hints\n\n**Acceptance Criteria:**\n- [ ] `get_module_registers()` calls Firmware API correctly\n- [ ] `get_register_info()` calls Firmware API correctly\n- [ ] Proper error handling\n- [ ] Timeout configured\n- [ ] Logging implemented\n\n---\n\n### **Task 2: Create Register Sync Service** (6h)\n\n**File to create:**\n- `backend/app/services/register_sync_service.py`\n\n**Class Implementation:**\n\n```python\nclass RegisterSyncService:\n    \"\"\"\n    Service to sync register metadata from Firmware to Database\n    \"\"\"\n    \n    async def sync_module_registers(\n        self, \n        db: AsyncSession, \n        module_addr: int\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Sync all registers for a specific module\n        \n        Process:\n        1. Fetch register metadata from Firmware API\n        2. For each register:\n           - Check if exists in DB (by address)\n           - If exists: UPDATE metadata\n           - If not exists: INSERT new record\n        3. Commit transaction\n        \n        Returns:\n            {\n                \"success\": true,\n                \"synced\": 51,\n                \"updated\": 3,\n                \"created\": 48,\n                \"module_addr\": 2\n            }\n        \"\"\"\n        try:\n            # 1. Fetch from Firmware\n            firmware_response = await unified_firmware_service.get_module_registers(module_addr)\n            \n            if not firmware_response.get(\"success\"):\n                return {\n                    \"success\": False,\n                    \"error\": firmware_response.get(\"error\"),\n                    \"synced\": 0,\n                    \"updated\": 0,\n                    \"created\": 0\n                }\n            \n            registers_data = firmware_response[\"data\"][\"registers\"]\n            \n            synced_count = 0\n            updated_count = 0\n            created_count = 0\n            \n            # 2. Process each register\n            for reg_data in registers_data:\n                # Convert mode string to enum\n                mode = self._convert_mode(reg_data[\"mode\"])\n                access_level = self._convert_access_level(reg_data[\"access_level\"])\n                \n                # Check if exists\n                existing = await db.execute(\n                    select(RegisterModel).where(\n                        RegisterModel.address == reg_data[\"address\"]\n                    )\n                )\n                existing_register = existing.scalar_one_or_none()\n                \n                if existing_register:\n                    # UPDATE\n                    existing_register.mode = mode\n                    existing_register.access_level = access_level\n                    existing_register.is_safe_register = reg_data[\"is_safe_register\"]\n                    existing_register.unit = reg_data[\"unit\"]\n                    existing_register.description = reg_data[\"description\"]\n                    updated_count += 1\n                else:\n                    # INSERT\n                    new_register = RegisterModel(\n                        name=reg_data[\"description\"][:100],\n                        address=reg_data[\"address\"],\n                        mode=mode,\n                        access_level=access_level,\n                        is_safe_register=reg_data[\"is_safe_register\"],\n                        unit=reg_data[\"unit\"],\n                        description=reg_data[\"description\"]\n                    )\n                    db.add(new_register)\n                    created_count += 1\n                \n                synced_count += 1\n            \n            # 3. Commit\n            await db.commit()\n            \n            return {\n                \"success\": True,\n                \"synced\": synced_count,\n                \"updated\": updated_count,\n                \"created\": created_count,\n                \"module_addr\": module_addr\n            }\n            \n        except Exception as e:\n            await db.rollback()\n            return {\n                \"success\": False,\n                \"error\": str(e),\n                \"synced\": 0,\n                \"updated\": 0,\n                \"created\": 0\n            }\n    \n    async def sync_all_modules(self, db: AsyncSession) -> Dict[str, Any]:\n        \"\"\"\n        Sync registers for all modules (Power, Safety, Motor, Dock)\n        \n        Returns:\n            {\n                \"success\": true,\n                \"total_synced\": 146,\n                \"total_updated\": 10,\n                \"total_created\": 136,\n                \"failed_modules\": []\n            }\n        \"\"\"\n        module_addresses = [2, 3, 4, 5]  # Power, Safety, Motor, Dock\n        \n        total_synced = 0\n        total_updated = 0\n        total_created = 0\n        failed_modules = []\n        \n        for module_addr in module_addresses:\n            result = await self.sync_module_registers(db, module_addr)\n            \n            if result[\"success\"]:\n                total_synced += result[\"synced\"]\n                total_updated += result[\"updated\"]\n                total_created += result[\"created\"]\n            else:\n                failed_modules.append(module_addr)\n        \n        return {\n            \"success\": len(failed_modules) == 0,\n            \"total_synced\": total_synced,\n            \"total_updated\": total_updated,\n            \"total_created\": total_created,\n            \"failed_modules\": failed_modules\n        }\n    \n    def _convert_mode(self, mode_str: str) -> RegisterMode:\n        \"\"\"Convert mode string to enum\"\"\"\n        mode_map = {\n            \"READ\": RegisterMode.READ,\n            \"WRITE\": RegisterMode.WRITE,\n            \"READ_WRITE\": RegisterMode.READ_WRITE,\n            \"WRITE_ONCE\": RegisterMode.READ_WRITE  # Map to READ_WRITE\n        }\n        return mode_map.get(mode_str, RegisterMode.READ)\n    \n    def _convert_access_level(self, access_str: str) -> RegisterAccessLevel:\n        \"\"\"Convert access level string to enum\"\"\"\n        access_map = {\n            \"USER\": RegisterAccessLevel.USER,\n            \"ADMIN\": RegisterAccessLevel.ADMIN,\n            \"SYSTEM\": RegisterAccessLevel.SYSTEM\n        }\n        return access_map.get(access_str, RegisterAccessLevel.USER)\n```\n\n**Technical Requirements:**\n- Transaction management (commit/rollback)\n- Upsert logic (update if exists, insert if not)\n- Enum conversion (string to enum)\n- Error handling per register\n- Batch processing\n- Logging per operation\n\n**Acceptance Criteria:**\n- [ ] Syncs all registers correctly\n- [ ] Updates existing registers\n- [ ] Creates new registers\n- [ ] Handles errors gracefully\n- [ ] Transaction rollback on error\n- [ ] Accurate statistics returned\n\n---\n\n### **Task 3: Create Admin API Endpoint** (3h)\n\n**File to create:**\n- `backend/app/api/v1/admin/register_sync.py`\n\n**Endpoint Implementation:**\n\n```python\nrouter = APIRouter(prefix=\"/api/v1/admin/registers\", tags=[\"admin\", \"registers\"])\n\nclass RegisterSyncRequest(BaseModel):\n    module_addr: Optional[int] = None  # If None, sync all modules\n\nclass RegisterSyncResponse(BaseModel):\n    success: bool\n    total_synced: int\n    total_updated: int\n    total_created: int\n    failed_modules: list = []\n    message: str\n\n@router.post(\"/sync-from-firmware\", response_model=RegisterSyncResponse)\nasync def sync_registers_from_firmware(\n    request: RegisterSyncRequest = None,\n    db: AsyncSession = Depends(get_db),\n    current_user: User = Depends(require_permission(\"system\", \"configure\"))\n):\n    \"\"\"\n    🔄 Sync register metadata from Firmware to Database\n    \n    Requires SYSTEM/CONFIGURE permission.\n    \n    Request:\n        - module_addr (optional): If provided, sync only that module. \n                                  If None, sync all modules.\n    \n    Response:\n        - total_synced: Total number of registers synced\n        - total_updated: Number of existing registers updated\n        - total_created: Number of new registers created\n        - failed_modules: List of module addresses that failed to sync\n    \n    Example:\n        POST /api/v1/admin/registers/sync-from-firmware\n        Body: {\"module_addr\": 2}\n        \n        Response: {\n            \"success\": true,\n            \"total_synced\": 51,\n            \"total_updated\": 3,\n            \"total_created\": 48,\n            \"failed_modules\": [],\n            \"message\": \"Successfully synced module 2\"\n        }\n    \"\"\"\n    try:\n        if request and request.module_addr is not None:\n            # Sync specific module\n            result = await register_sync_service.sync_module_registers(\n                db, request.module_addr\n            )\n            \n            if not result[\"success\"]:\n                raise HTTPException(\n                    status_code=500,\n                    detail=f\"Failed to sync module {request.module_addr}: {result['error']}\"\n                )\n            \n            return RegisterSyncResponse(\n                success=True,\n                total_synced=result[\"synced\"],\n                total_updated=result[\"updated\"],\n                total_created=result[\"created\"],\n                message=f\"Successfully synced module {request.module_addr}\"\n            )\n        else:\n            # Sync all modules\n            result = await register_sync_service.sync_all_modules(db)\n            \n            return RegisterSyncResponse(\n                success=result[\"success\"],\n                total_synced=result[\"total_synced\"],\n                total_updated=result[\"total_updated\"],\n                total_created=result[\"total_created\"],\n                failed_modules=result.get(\"failed_modules\", []),\n                message=\"Register sync completed\" if result[\"success\"] \n                       else \"Register sync completed with errors\"\n            )\n            \n    except HTTPException:\n        raise\n    except Exception as e:\n        raise HTTPException(\n            status_code=500,\n            detail=f\"Failed to sync registers: {str(e)}\"\n        )\n```\n\n**Technical Requirements:**\n- Permission check: SYSTEM/CONFIGURE required\n- Request body validation\n- Error handling\n- Logging\n- OpenAPI documentation\n\n**File to modify:**\n- `backend/app/main.py` - Add router\n\n```python\nfrom app.api.v1.admin import register_sync\n\napp.include_router(register_sync.router)\n```\n\n**Acceptance Criteria:**\n- [ ] Endpoint accessible at `/api/v1/admin/registers/sync-from-firmware`\n- [ ] Permission check enforced\n- [ ] Sync specific module works\n- [ ] Sync all modules works\n- [ ] Error responses formatted correctly\n- [ ] OpenAPI docs generated\n\n---\n\n### **Task 4: Extend Register Query APIs** (4h)\n\n**File to modify:**\n- `backend/app/api/v1/registers.py`\n\n**Enhancements:**\n\n#### **1. Add Query Filters**\n\n```python\n@router.get(\"/\", response_model=List[RegisterOut])\nasync def list_registers(\n    module_addr: Optional[int] = Query(None, description=\"Filter by module address\"),\n    mode: Optional[RegisterMode] = Query(None, description=\"Filter by mode\"),\n    access_level: Optional[RegisterAccessLevel] = Query(None, description=\"Filter by access level\"),\n    db: AsyncSession = Depends(get_db),\n    current_user: User = Depends(require_permission(\"monitoring\", \"read\")),\n):\n    \"\"\"\n    📋 List all registers with optional filters\n    \n    Filters:\n        - module_addr: Module address (2=Power, 3=Safety, 4=Motor, 5=Dock)\n        - mode: Register mode (READ, WRITE, READ_WRITE)\n        - access_level: Access level (USER, ADMIN, SYSTEM)\n    \n    Examples:\n        GET /api/v1/registers?mode=READ\n        GET /api/v1/registers?module_addr=2&access_level=USER\n    \"\"\"\n    items = await register_service.list_with_filters(\n        db, \n        module_addr=module_addr,\n        mode=mode,\n        access_level=access_level\n    )\n    return items\n```\n\n#### **2. Add Get By Address Endpoint**\n\n```python\n@router.get(\"/by-address/{address}\", response_model=RegisterOut)\nasync def get_register_by_address(\n    address: str,\n    db: AsyncSession = Depends(get_db),\n    current_user: User = Depends(require_permission(\"monitoring\", \"read\")),\n):\n    \"\"\"\n    📖 Get register details by address (e.g., 0x0000)\n    \n    Example:\n        GET /api/v1/registers/by-address/0x0000\n    \"\"\"\n    register = await register_service.get_by_address(db, address)\n    if not register:\n        raise HTTPException(status_code=404, detail=\"Register not found\")\n    return register\n```\n\n**File to modify:**\n- `backend/app/services/register_service.py`\n\n```python\nclass RegisterService:\n    async def list_with_filters(\n        self, \n        db: AsyncSession,\n        module_addr: Optional[int] = None,\n        mode: Optional[RegisterMode] = None,\n        access_level: Optional[RegisterAccessLevel] = None\n    ) -> List[RegisterModel]:\n        \"\"\"\n        List registers with optional filters\n        \n        Note: module_addr filter requires parsing address field\n        (first byte of hex address = module address)\n        \"\"\"\n        query = select(RegisterModel)\n        \n        if mode:\n            query = query.where(RegisterModel.mode == mode)\n        \n        if access_level:\n            query = query.where(RegisterModel.access_level == access_level)\n        \n        # Module filtering logic (if needed)\n        # This might require a separate module_addr column\n        \n        result = await db.execute(query)\n        return list(result.scalars().all())\n```\n\n**Technical Requirements:**\n- Query parameter validation\n- Filter combination support\n- Efficient SQL queries\n- Index utilization\n\n**Acceptance Criteria:**\n- [ ] Filter by mode works\n- [ ] Filter by access_level works\n- [ ] Multiple filters work together\n- [ ] Get by address works\n- [ ] Proper error messages\n- [ ] Query performance acceptable\n\n---\n\n### **Task 5: Integration Testing** (4h)\n\n**File to create:**\n- `backend/tests/test_register_sync.py`\n\n**Test Cases:**\n\n```python\nimport pytest\nfrom httpx import AsyncClient\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\n@pytest.mark.asyncio\nasync def test_sync_module_registers(db: AsyncSession):\n    \"\"\"Test syncing registers from Firmware\"\"\"\n    result = await register_sync_service.sync_module_registers(db, module_addr=2)\n    \n    assert result[\"success\"] is True\n    assert result[\"synced\"] > 0\n    assert result[\"module_addr\"] == 2\n\n@pytest.mark.asyncio\nasync def test_sync_all_modules(db: AsyncSession):\n    \"\"\"Test syncing all modules\"\"\"\n    result = await register_sync_service.sync_all_modules(db)\n    \n    assert result[\"success\"] is True\n    assert result[\"total_synced\"] > 0\n\n@pytest.mark.asyncio\nasync def test_register_query_by_mode(client: AsyncClient, auth_headers: dict):\n    \"\"\"Test querying registers by mode\"\"\"\n    response = await client.get(\n        \"/api/v1/registers?mode=READ\",\n        headers=auth_headers\n    )\n    \n    assert response.status_code == 200\n    data = response.json()\n    assert len(data) > 0\n    for reg in data:\n        assert reg[\"mode\"] == \"READ\"\n\n@pytest.mark.asyncio\nasync def test_register_query_by_access_level(client: AsyncClient, auth_headers: dict):\n    \"\"\"Test querying registers by access level\"\"\"\n    response = await client.get(\n        \"/api/v1/registers?access_level=USER\",\n        headers=auth_headers\n    )\n    \n    assert response.status_code == 200\n    data = response.json()\n    for reg in data:\n        assert reg[\"access_level\"] == \"USER\"\n\n@pytest.mark.asyncio\nasync def test_admin_sync_endpoint(client: AsyncClient, admin_auth_headers: dict):\n    \"\"\"Test admin sync endpoint\"\"\"\n    response = await client.post(\n        \"/api/v1/admin/registers/sync-from-firmware\",\n        json={\"module_addr\": 2},\n        headers=admin_auth_headers\n    )\n    \n    assert response.status_code == 200\n    data = response.json()\n    assert data[\"success\"] is True\n    assert data[\"total_synced\"] > 0\n\n@pytest.mark.asyncio\nasync def test_sync_permission_denied(client: AsyncClient, user_auth_headers: dict):\n    \"\"\"Test sync requires admin permission\"\"\"\n    response = await client.post(\n        \"/api/v1/admin/registers/sync-from-firmware\",\n        json={\"module_addr\": 2},\n        headers=user_auth_headers\n    )\n    \n    assert response.status_code == 403  # Forbidden\n\n@pytest.mark.asyncio\nasync def test_get_register_by_address(client: AsyncClient, auth_headers: dict):\n    \"\"\"Test get register by address\"\"\"\n    # First, sync some registers\n    await register_sync_service.sync_module_registers(db, 2)\n    \n    # Then query\n    response = await client.get(\n        \"/api/v1/registers/by-address/0x0000\",\n        headers=auth_headers\n    )\n    \n    assert response.status_code == 200\n    data = response.json()\n    assert data[\"address\"] == \"0x0000\"\n\n@pytest.mark.asyncio\nasync def test_sync_upsert_logic(db: AsyncSession):\n    \"\"\"Test that sync updates existing records\"\"\"\n    # First sync\n    result1 = await register_sync_service.sync_module_registers(db, 2)\n    created1 = result1[\"created\"]\n    \n    # Second sync (should update, not create new)\n    result2 = await register_sync_service.sync_module_registers(db, 2)\n    created2 = result2[\"created\"]\n    updated2 = result2[\"updated\"]\n    \n    assert created2 == 0  # No new records\n    assert updated2 == result1[\"synced\"]  # All updated\n```\n\n**Test Coverage:**\n- [ ] Unit tests for sync service\n- [ ] Integration tests for API endpoints\n- [ ] Permission tests\n- [ ] Error handling tests\n- [ ] Upsert logic tests\n- [ ] Query filter tests\n\n**Acceptance Criteria:**\n- [ ] All tests passing\n- [ ] Code coverage > 80%\n- [ ] Edge cases covered\n- [ ] Performance acceptable\n\n---\n\n### **Task 6: Documentation** (2h)\n\n**File to create:**\n- `backend/docs/API_REGISTER_SYNC.md`\n\n**Documentation Sections:**\n\n```markdown\n# Register Sync API Documentation\n\n## Overview\nAPI để sync register metadata từ Firmware vào Database.\n\n## Architecture\n[Architecture diagram]\n\n## Admin Endpoints\n\n### POST /api/v1/admin/registers/sync-from-firmware\nSync register metadata từ Firmware.\n\n**Permission:** SYSTEM/CONFIGURE\n\n**Request Body:**\n```json\n{\n  \"module_addr\": 2  // Optional\n}\n```\n\n**Response:**\n```json\n{\n  \"success\": true,\n  \"total_synced\": 51,\n  \"total_updated\": 3,\n  \"total_created\": 48,\n  \"failed_modules\": [],\n  \"message\": \"Successfully synced module 2\"\n}\n```\n\n## Query Endpoints\n\n### GET /api/v1/registers\nList registers với filters.\n\n**Query Parameters:**\n- `module_addr` (optional): Filter by module address\n- `mode` (optional): Filter by mode (READ/WRITE/READ_WRITE)\n- `access_level` (optional): Filter by access level (USER/ADMIN/SYSTEM)\n\n**Examples:**\n```bash\nGET /api/v1/registers?mode=READ\nGET /api/v1/registers?module_addr=2&access_level=USER\n```\n\n### GET /api/v1/registers/by-address/{address}\nGet register by address.\n\n**Example:**\n```bash\nGET /api/v1/registers/by-address/0x0000\n```\n\n## Usage Guide\n\n### Initial Setup\n1. Ensure Firmware is running and accessible\n2. Login as admin user\n3. Call sync endpoint to populate database\n\n### Periodic Sync\nRecommend scheduling periodic sync (e.g., daily) to keep metadata updated.\n\n### Error Handling\n[Error scenarios and solutions]\n```\n\n**Acceptance Criteria:**\n- [ ] Complete API documentation\n- [ ] Usage examples\n- [ ] Error handling guide\n- [ ] Architecture diagrams\n\n---\n\n## 🔧 **TECHNICAL SPECIFICATIONS**\n\n### **Module Mapping**\n\n| Module | Address | Expected Registers |\n|--------|---------|--------------------|\n| Power | 2 | ~51 |\n| Safety | 3 | ~30 |\n| Motor | 4 | ~25 |\n| Dock | 5 | ~40 |\n| **Total** | | **~146** |\n\n### **Enum Mappings**\n\n#### **RegisterMode**\n```python\nclass RegisterMode(str, Enum):\n    READ = \"READ\"\n    WRITE = \"WRITE\"\n    READ_WRITE = \"READ_WRITE\"\n```\n\n#### **RegisterAccessLevel**\n```python\nclass RegisterAccessLevel(str, Enum):\n    USER = \"USER\"\n    ADMIN = \"ADMIN\"\n    SYSTEM = \"SYSTEM\"\n```\n\n### **Performance Requirements**\n\n- Sync single module: < 2 seconds\n- Sync all modules: < 10 seconds\n- Query with filters: < 50ms\n- Database write per register: < 10ms\n\n---\n\n## 📊 **SUCCESS CRITERIA**\n\n### **Functional Requirements**\n- ✅ Can sync registers from Firmware\n- ✅ Can sync single module or all modules\n- ✅ Upsert logic works (update if exists, insert if not)\n- ✅ Query APIs work with filters\n- ✅ Permission checks enforced\n\n### **Non-Functional Requirements**\n- ✅ Performance < 10s for full sync\n- ✅ Transaction safety (rollback on error)\n- ✅ No data loss during sync\n- ✅ Logging comprehensive\n\n### **Integration Requirements**\n- ✅ Works with Firmware API\n- ✅ Frontend can trigger sync\n- ✅ Frontend can query registers\n\n---\n\n## 📅 **TIMELINE**\n\n| Day | Tasks | Deliverables |\n|-----|-------|-------------|\n| Day 1 | Task 1 + Task 2 | Firmware client + Sync service |\n| Day 2 | Task 3 + Task 4 | Admin API + Query enhancements |\n| Day 3 | Task 5 + Task 6 | Testing + Documentation |\n\n**Total Estimate:** 21 hours (~3 days with 1 BE engineer)\n\n---\n\n## 🔗 **DEPENDENCIES**\n\n### **Depends On:**\n- ✅ Firmware Issue: \"Implement Register Metadata API\" (MUST be completed first)\n- ✅ Existing `Register` model in database\n- ✅ Existing `unified_firmware_service`\n\n### **Blocks:**\n- Frontend display of register metadata\n- Frontend configuration UI based on register metadata\n\n---\n\n## 📚 **REFERENCES**\n\n### **Related Files:**\n- `backend/app/models/register.py` - Register model\n- `backend/app/schemas/registers.py` - Register schemas\n- `backend/app/services/unified_firmware_service.py` - Firmware client\n- `backend/app/api/v1/registers.py` - Register APIs\n\n### **Related Issues:**\n- #176 - Original issue requesting address & mode support\n- Firmware Issue: \"Implement Register Metadata API\"\n\n---\n\n## 💡 **IMPLEMENTATION NOTES**\n\n### **Sync Strategy**\n- Use upsert pattern (UPDATE if exists, INSERT if not)\n- Transaction per module (rollback on module failure)\n- Continue with other modules if one fails\n\n### **Performance Optimization**\n- Batch database operations\n- Use indexes on address, mode, access_level\n- Consider caching for frequently queried registers\n\n### **Error Handling**\n- Network timeout: Retry with exponential backoff\n- Database error: Rollback transaction\n- Partial failure: Continue with other modules\n\n---\n\n## ✅ **DEFINITION OF DONE**\n\n- [ ] All 6 tasks completed\n- [ ] Unit tests passing (coverage > 80%)\n- [ ] Integration tests passing\n- [ ] Documentation updated\n- [ ] Code reviewed and approved\n- [ ] Manual testing completed\n- [ ] Performance requirements met\n- [ ] Works with Firmware API\n- [ ] Merged to main branch\n\n---\n\n**Assigned to:** @backend-team  \n**Labels:** `backend`, `api`, `database`, `enhancement`, `priority: high`  \n**Milestone:** Issue #176 Resolution",
  "labels": ["backend", "api", "database", "enhancement", "priority: high"],
  "assignees": []
}

