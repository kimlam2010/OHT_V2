{
  "title": "⚠️ FW: RS485/Modbus data invalid (all zeros), sporadic malformed frames, long BOOT state",
  "body": "## 🔎 Summary\nFirmware RS485/Modbus comms appear electrically OK (CRC valid, ~96% transport success), but many registers return all-zero payloads; some responses are malformed (Slave=0x00/Func=0x00); occasional timeouts; and system remains in BOOT for a long time. This leads to repeated `Data validation failed` across modules.\n\n## 📜 Evidence (from logs)\n- Success path:\n  - TX: `02 03 00 30 00 08 44 30` → RX: `02 03 10 00 00 ... 00 A0 1D` (CRC OK) but values all 0\n  - Similar for 0x0041, 0x001C, 0x0040, 0x0049, 0x0010 on slaves 0x02/0x04\n- Malformed/short frames:\n  - RX short/rubbish: `00 00 0B 7A`, `00 00 00 8B FF` (Slave=0x00/Func=0x00)\n- Exceptions:\n  - Slaves 0x06/0x07: `06 83 02 ...` `07 83 02 ...` → ILLEGAL_DATA_ADDRESS\n- Timeouts: intermittent (status=-4)\n- State machine: `STATE BOOT timeout` (system not READY)\n- COMM_HEALTH transport success ~96%, but semantic data invalid (all zeros).\n\n## 🎯 Impact\n- Telemetry/diagnostics unreliable\n- Control/safety decisions blocked (system not READY)\n- Backend receives transport success but invalid semantic data\n\n## 🧭 Likely Root Causes\n1. Module state not READY (still BOOT) → registers return 0\n2. Register map mismatch (addresses/qty/endian) for modules 0x02/0x04\n3. RS485 timing: DE/RE turnaround / inter-frame gap too short → occasional malformed/short frames\n4. Bus integrity: termination/bias/ground/shield\n5. Polling non-existent modules 0x06/0x07 → exception 0x83/0x02\n\n## ✅ Action Items (Proposed Fix Plan)\n1) Initialization & State\n- Ensure init-sequence completes and state→READY < 10s before polling.\n- Gate polling by discovery; skip polling modules not present.\n\n2) Register Map Validation\n- Re-validate addresses/quantities for 0x02 (Power) and 0x04 (Motor).\n- Start with small reads (2–4 regs), confirm endian/scales, then expand.\n\n3) RS485 Timing & Robustness\n- Set silent interval ≥ 3.5 chars; TX→RX turnaround ≥ 1–2 ms (per baud).\n- Add inter-request backoff 50→150 ms with jitter.\n- Keep retries=3, but downgrade rate when invalid data repeats.\n\n4) Bus Hardware Checklist\n- Verify 120Ω termination, bias resistors, shield/ground continuity, connectors.\n- Check cable length/load and routing away from noise.\n\n5) Error Handling & Health Metrics\n- Treat CRC-OK but all-zero payload as invalid semantic data (don’t count as full success).\n- Separate metrics: transport_success vs value_valid_rate.\n- For ILLEGAL_DATA_ADDRESS, suppress repeated logs and skip that register.\n\n6) WebSocket (FYI)\n- WS firmware connects/disconnects periodically; confirm heartbeat/keepalive but not blocking RS485.\n\n## 📐 Acceptance Criteria\n- State transitions to READY in < 10s.\n- No malformed frames (no Slave=0x00/Func=0x00).\n- p95 timeout ≈ 0 in steady state.\n- Power (0x02) & Motor (0x04) readings non-zero and pass validator.\n- No polling of non-existent modules (0x06/0x07) unless discovered.\n- COMM_HEALTH: transport_success ≥ 99%, value_valid_rate ≥ 98%.\n\n## 🔧 Suggested Changes (Code)\n- Increase inter-frame delay and turnaround in HAL RS485 driver.\n- Add READY gate + discovery before polling in polling manager.\n- Refactor register map constants; add unit tests for packing/unpacking.\n- Improve parser to reject all-zero frames as invalid for specific register groups.\n\n## 📎 Attachments\n- Snippets included above; full logs available on request.\n\n/cc @backend @firmware @embed — needs FW ownership to implement timing, state gating, and register map validation."
}
