---
description:
globs:
alwaysApply: true
---
# ğŸš€ BACKEND DEVELOPMENT RULES - OHT-50

**PhiÃªn báº£n:** 1.0  
**NgÃ y cáº­p nháº­t:** 2025-01-28  
**Má»¥c tiÃªu:** Chuáº©n hÃ³a quy trÃ¬nh phÃ¡t triá»ƒn backend cho OHT-50 vá»›i focus vÃ o performance, security vÃ  integration

---

## ğŸ¯ **VAI TRÃ’ & TRÃCH NHIá»†M**

### **BACKEND TEAM LEAD**
- **Quáº£n lÃ½ tá»•ng thá»ƒ:** Architecture, performance, security, integration
- **Quality Control:** Review táº¥t cáº£ deliverables trÆ°á»›c khi approve
- **Coordination:** Äáº£m báº£o consistency giá»¯a cÃ¡c services
- **Technical Leadership:** Äáº£m báº£o technical excellence

### **CORE DEVELOPERS**
- **Service Implementation:** Robot Control, Telemetry, Safety, LiDAR Processing
- **API Development:** REST API, WebSocket, Real-time communication
- **Database Design:** SQLite, Redis, Data modeling
- **Integration:** Firmware, Hardware, Frontend integration

### **DEVOPS ENGINEER**
- **Infrastructure:** Docker, CI/CD, Monitoring, Deployment
- **Performance:** Load testing, Optimization, Scaling
- **Security:** Security scanning, Compliance, Hardening
- **Operations:** Backup, Recovery, Maintenance

---

## ğŸš¨ **CRITICAL REQUIREMENTS (Báº®T BUá»˜C)**

### **1. PERFORMANCE FIRST APPROACH**
```
âŒ KHÃ”NG BAO GIá»œ compromise performance cho features
âœ… LUÃ”N LUÃ”N optimize cho real-time requirements
âœ… Má»–I API endpoint pháº£i meet performance targets
âœ… TEST performance: API < 50ms, WebSocket < 20ms, DB < 10ms
```

### **2. SECURITY BY DESIGN**
```
BEFORE APPROVAL:
â–¡ Security review completed
â–¡ Authentication/Authorization implemented
â–¡ Data encryption configured
â–¡ Input validation active
â–¡ Audit logging enabled
```

### **3. ARCHITECTURE COMPLIANCE (Báº®T BUá»˜C)**
```
MUST FOLLOW ARCHITECTURE DOCUMENTS:
- Äá»ŒC docs/03-ARCHITECTURE/ TRÆ¯á»šC KHI IMPLEMENT
- Äá»ŒC ADR-004-COMMUNICATION_PROTOCOLS.md cho giao tiáº¿p
- Äá»ŒC ADR-001-SYSTEM_ARCHITECTURE.md cho kiáº¿n trÃºc tá»•ng thá»ƒ
- Äá»ŒC ARCHITECTURE_REVIEW_SUMMARY.md cho tá»•ng quan

ARCHITECTURE HIá»‚U ÄÃšNG:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         Protocol Gateway            â”‚  â† FIRMWARE LÃ€M VIá»†C NÃ€Y
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚             â”‚             â”‚
â”Œâ”€â”€â”€â–¼â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”
â”‚ HTTP  â”‚   â”‚WebSocketâ”‚   â”‚  RS485  â”‚
â”‚ REST  â”‚   â”‚Streamingâ”‚   â”‚ Modbus  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â”‚             â”‚             â”‚
â”Œâ”€â”€â”€â–¼â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”
â”‚Center â”‚   â”‚Frontend â”‚   â”‚Hardware â”‚
â”‚System â”‚   â”‚  UI     â”‚   â”‚Modules  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

BACKEND CHá»ˆ GIAO TIáº¾P Vá»šI FIRMWARE QUA HTTP/REST API!
BACKEND KHÃ”NG BAO GIá»œ TRá»°C TIáº¾P RS485!
```

### **4. INTEGRATION COMPLIANCE**
```
MUST FOLLOW:
- HTTP/REST API cho Firmware communication
- WebSocket real-time cho frontend communication
- REST API standards cho external integration
- Database schema theo REQ_BE_03
- Security standards theo REQ_BE_04
```

### **5. HARDWARE & FIRMWARE INTEGRATION (Báº®T BUá»˜C)**
```
âŒ KHÃ”NG BAO GIá»œ mock data vá»›i hardware vÃ  firmware
âŒ KHÃ”NG BAO GIá»œ Backend trá»±c tiáº¿p giao tiáº¿p RS485
âœ… LUÃ”N LUÃ”N giao tiáº¿p vá»›i Firmware qua HTTP/REST API
âœ… LUÃ”N LUÃ”N Ä‘á»ƒ Firmware lÃ m Protocol Gateway
âœ… PHáº¢I bÃ¡o rÃµ khi sá»­ dá»¥ng mock data (chá»‰ cho development)
âœ… PHáº¢I test vá»›i Firmware tháº­t trÆ°á»›c khi deploy

FIRMWARE INTEGRATION RULES:
â–¡ Backend chá»‰ giao tiáº¿p vá»›i Firmware qua HTTP API
â–¡ Firmware má»›i lÃ  ngÆ°á»i giao tiáº¿p RS485 vá»›i hardware
â–¡ Backend khÃ´ng bao giá» biáº¿t vá» RS485 protocol
â–¡ Backend chá»‰ gá»­i commands vÃ  nháº­n data tá»« Firmware
â–¡ Mock data chá»‰ dÃ¹ng cho unit testing Firmware API

MOCK DATA RULES:
â–¡ Chá»‰ Ä‘Æ°á»£c dÃ¹ng cho unit testing
â–¡ Pháº£i cÃ³ flag rÃµ rÃ ng: use_mock=True
â–¡ Pháº£i log warning khi sá»­ dá»¥ng mock
â–¡ KhÃ´ng Ä‘Æ°á»£c dÃ¹ng trong production
â–¡ Pháº£i cÃ³ comment giáº£i thÃ­ch lÃ½ do mock
```

---

## ğŸ“‹ **QUY TRÃŒNH DEVELOPMENT 5 BÆ¯á»šC (Báº®T BUá»˜C)**

### **BÆ¯á»šC 1: ARCHITECTURE REVIEW**
```
Backend Team Lead MUST:
â–¡ Äá»ŒC docs/03-ARCHITECTURE/ TRÆ¯á»šC KHI REVIEW
â–¡ Review service architecture design
â–¡ Validate performance requirements
â–¡ Confirm security implementation
â–¡ Confirm Firmware integration approach (HTTP API, NOT RS485)
â–¡ Approve technical approach
```

### **BÆ¯á»šC 2: SERVICE IMPLEMENTATION**
```
Core Developers MUST:
â–¡ Implement service theo design patterns
â–¡ Add comprehensive error handling
â–¡ Implement logging vÃ  monitoring
â–¡ Test service functionality
â–¡ Validate performance metrics
```

### **BÆ¯á»šC 3: INTEGRATION TESTING**
```
DevOps Engineer MUST:
â–¡ Test service integration
â–¡ Validate communication protocols
â–¡ Test performance under load
â–¡ Verify security implementation
â–¡ Test error recovery
```

### **BÆ¯á»šC 4: QUALITY GATE**
```
Backend Team Lead MUST:
â–¡ Review complete implementation
â–¡ Validate performance requirements
â–¡ Check security compliance
â–¡ Approve for deployment
â–¡ Update documentation
```

### **BÆ¯á»šC 5: DEPLOYMENT & MONITORING**
```
DevOps Engineer MUST:
â–¡ Deploy to staging environment
â–¡ Monitor performance metrics
â–¡ Validate security compliance
â–¡ Deploy to production
â–¡ Setup monitoring alerts
```

---

## ğŸ—ï¸ **ARCHITECTURE STANDARDS**

### **Service Architecture (Báº®T BUá»˜C)**
```python
# Service Base Class
class BaseService:
    def __init__(self):
        self.logger = logging.getLogger(self.__class__.__name__)
        self.metrics = MetricsCollector()
        self.cache = RedisCache()
        
    async def handle_request(self, request: Request) -> Response:
        """Standard request handling with performance monitoring"""
        start_time = time.time()
        try:
            # Validate request
            await self.validate_request(request)
            
            # Process request
            result = await self.process_request(request)
            
            # Log metrics
            self.metrics.record_success(time.time() - start_time)
            
            return Response(success=True, data=result)
            
        except Exception as e:
            self.metrics.record_error(time.time() - start_time, str(e))
            self.logger.error(f"Request failed: {e}")
            raise
```

### **API Standards (Báº®T BUá»˜C)**
```python
# API Response Format
class APIResponse:
    def __init__(self, success: bool, data: Any = None, 
                 message: str = "", error_code: str = None):
        self.success = success
        self.data = data
        self.message = message
        self.error_code = error_code
        self.timestamp = datetime.utcnow().isoformat()
        self.request_id = str(uuid.uuid4())

# Performance Monitoring
class PerformanceMiddleware:
    async def __call__(self, request: Request, call_next):
        start_time = time.time()
        response = await call_next(request)
        process_time = time.time() - start_time
        
        # Record performance metrics
        if process_time > 0.1:  # Log slow requests
            logger.warning(f"Slow request: {request.url} took {process_time}s")
            
        return response
```

---

## ğŸ”§ **TECHNICAL STANDARDS**

### **Database Standards (Báº®T BUá»˜C)**
```sql
-- Performance optimized schema
CREATE TABLE robot_status (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    robot_id VARCHAR(50) NOT NULL,
    status VARCHAR(20) NOT NULL,
    position_x DECIMAL(10,3),
    position_y DECIMAL(10,3),
    battery_level INTEGER,
    temperature DECIMAL(5,2),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Indexes for performance
CREATE INDEX idx_robot_status_robot_id ON robot_status(robot_id);
CREATE INDEX idx_robot_status_updated ON robot_status(updated_at);
CREATE INDEX idx_robot_status_status ON robot_status(status);
```

### **Security Standards (Báº®T BUá»˜C)**
```python
# Authentication Middleware
class AuthMiddleware:
    def __init__(self, jwt_secret: str):
        self.jwt_secret = jwt_secret
        
    async def authenticate(self, request: Request) -> Optional[User]:
        token = request.headers.get("Authorization")
        if not token or not token.startswith("Bearer "):
            raise HTTPException(status_code=401, detail="Invalid token")
            
        try:
            payload = jwt.decode(token[7:], self.jwt_secret, algorithms=["HS256"])
            return await self.get_user(payload["user_id"])
        except jwt.ExpiredSignatureError:
            raise HTTPException(status_code=401, detail="Token expired")
        except jwt.InvalidTokenError:
            raise HTTPException(status_code=401, detail="Invalid token")

# Input Validation
class InputValidator:
    @staticmethod
    def validate_robot_command(command: Dict) -> bool:
        required_fields = ["command_type", "parameters"]
        if not all(field in command for field in required_fields):
            raise ValueError("Missing required fields")
            
        if command["command_type"] not in ["move", "stop", "pause", "resume"]:
            raise ValueError("Invalid command type")
            
        return True
```

### **Integration Standards (Báº®T BUá»˜C)**
```python
# Firmware Integration Service - MUST USE REAL FIRMWARE
class FirmwareIntegrationService:
    def __init__(self, firmware_url: str = "http://localhost:8081"):
        self.firmware_url = firmware_url
        self.http_client = httpx.AsyncClient(base_url=firmware_url)
        
        # WARNING: This service MUST connect to real Firmware
        # DO NOT use mock data in production
        logger.warning("Firmware Integration: Connecting to REAL Firmware at %s", firmware_url)
        
    async def get_robot_status(self) -> Dict[str, Any]:
        """Get robot status from Firmware via HTTP API"""
        try:
            response = await self.http_client.get("/api/v1/robot/status")
            if response.status_code == 200:
                return response.json()
            else:
                raise FirmwareCommunicationException(f"Failed to get robot status: {response.status_code}")
        except Exception as e:
            logger.error("âŒ Failed to get robot status: %s", e)
            raise FirmwareCommunicationException(f"Robot status request failed: {e}")
            
    async def send_robot_command(self, command: Dict[str, Any]) -> bool:
        """Send robot command to Firmware via HTTP API"""
        try:
            response = await self.http_client.post("/api/v1/robot/command", json=command)
            if response.status_code == 200:
                result = response.json()
                return result.get("success", False)
            else:
                logger.error("âŒ Robot command failed: %s", response.status_code)
                return False
        except Exception as e:
            logger.error("âŒ Failed to send robot command: %s", e)
            return False

# MOCK FIRMWARE SERVICE - FOR DEVELOPMENT ONLY
class MockFirmwareService:
    def __init__(self):
        # WARNING: This is MOCK data - NOT for production use
        logger.warning("ğŸ§ª MOCK Firmware Service: Using simulated data - NOT real Firmware!")
        self.mock_data = self._initialize_mock_data()
        
    def _initialize_mock_data(self):
        # MOCK DATA - ONLY FOR UNIT TESTING
        # DO NOT USE IN PRODUCTION
        return {
            "robot_status": {
                "status": "idle",
                "position": {"x": 150.5, "y": 200.3},
                "battery_level": 87,
                "temperature": 42.5
            },
            "telemetry": {
                "motor_speed": 1500,
                "motor_temperature": 45,
                "dock_status": "ready",
                "safety_status": "normal"
            }
        }
```

---

## ğŸ“Š **PERFORMANCE REQUIREMENTS**

### **Response Time Targets (Báº®T BUá»˜C)**
```yaml
Performance Targets:
  API Endpoints:
    GET /robot/status: "< 50ms"
    POST /robot/control: "< 100ms"
    GET /telemetry/current: "< 50ms"
    POST /safety/emergency: "< 10ms"
    
  WebSocket Events:
    Telemetry updates: "< 20ms"
    Status changes: "< 50ms"
    Alert notifications: "< 100ms"
    
  Database Operations:
    Simple queries: "< 5ms"
    Complex queries: "< 50ms"
    Write operations: "< 10ms"
    
  System Performance:
    CPU usage: "< 60%"
    Memory usage: "< 3GB"
    Network latency: "< 1ms"
    Uptime: "> 99.9%"
```

### **Performance Monitoring (Báº®T BUá»˜C)**
```python
# Performance Monitoring Service
class PerformanceMonitor:
    def __init__(self):
        self.metrics = {}
        self.alerts = []
        
    async def record_metric(self, metric_name: str, value: float, tags: Dict = None):
        """Record performance metric"""
        timestamp = time.time()
        self.metrics[metric_name] = {
            "value": value,
            "timestamp": timestamp,
            "tags": tags or {}
        }
        
        # Check thresholds
        await self.check_thresholds(metric_name, value)
        
    async def check_thresholds(self, metric_name: str, value: float):
        """Check performance thresholds and generate alerts"""
        thresholds = {
            "api_response_time": 100,  # ms
            "websocket_latency": 50,   # ms
            "database_query_time": 10, # ms
            "cpu_usage": 80,           # %
            "memory_usage": 85         # %
        }
        
        if metric_name in thresholds and value > thresholds[metric_name]:
            alert = {
                "metric": metric_name,
                "value": value,
                "threshold": thresholds[metric_name],
                "timestamp": datetime.utcnow().isoformat()
            }
            self.alerts.append(alert)
            await self.send_alert(alert)
```

---

## ğŸ”’ **SECURITY REQUIREMENTS**

### **Security Implementation (Báº®T BUá»˜C)**
```python
# Security Configuration
SECURITY_CONFIG = {
    "jwt_secret": os.getenv("JWT_SECRET"),
    "jwt_expiry": 3600,  # 1 hour
    "password_min_length": 12,
    "max_login_attempts": 5,
    "lockout_duration": 1800,  # 30 minutes
    "session_timeout": 86400,  # 24 hours
    "rate_limit": {
        "requests_per_minute": 1000,
        "burst_limit": 100
    }
}

# Security Middleware
class SecurityMiddleware:
    def __init__(self):
        self.rate_limiter = RateLimiter()
        self.input_validator = InputValidator()
        
    async def __call__(self, request: Request, call_next):
        # Rate limiting
        if not await self.rate_limiter.check_limit(request):
            raise HTTPException(status_code=429, detail="Rate limit exceeded")
            
        # Input validation
        if request.method in ["POST", "PUT", "PATCH"]:
            await self.input_validator.validate_request(request)
            
        # Security headers
        response = await call_next(request)
        response.headers["X-Content-Type-Options"] = "nosniff"
        response.headers["X-Frame-Options"] = "DENY"
        response.headers["X-XSS-Protection"] = "1; mode=block"
        
        return response
```

---

## ğŸ”— **INTEGRATION REQUIREMENTS**

### **Firmware Integration (Báº®T BUá»˜C)**
```python
# Firmware Integration Service - HTTP API ONLY
class FirmwareIntegrationService:
    def __init__(self, firmware_url: str = "http://localhost:8081"):
        self.firmware_url = firmware_url
        self.http_client = httpx.AsyncClient(base_url=firmware_url)
        
    async def get_robot_status(self) -> Dict[str, Any]:
        """Get robot status from Firmware via HTTP API"""
        try:
            response = await self.http_client.get("/api/v1/robot/status")
            if response.status_code == 200:
                return response.json()
            else:
                raise FirmwareCommunicationException(f"Failed to get robot status: {response.status_code}")
        except Exception as e:
            logger.error("âŒ Failed to get robot status: %s", e)
            raise FirmwareCommunicationException(f"Robot status request failed: {e}")
            
    async def send_robot_command(self, command: Dict[str, Any]) -> bool:
        """Send robot command to Firmware via HTTP API"""
        try:
            # Validate command
            self.validate_command(command)
            
            # Send via HTTP API to Firmware
            response = await self.http_client.post("/api/v1/robot/command", json=command)
            if response.status_code == 200:
                result = response.json()
                success = result.get("success", False)
                
                if success:
                    await self.log_command(command, "success")
                else:
                    await self.log_command(command, "failed")
                    
                return success
            else:
                await self.log_command(command, "error", f"HTTP {response.status_code}")
                return False
                
        except Exception as e:
            await self.log_command(command, "error", str(e))
            raise
            
    async def get_telemetry_data(self) -> Dict[str, Any]:
        """Get telemetry data from Firmware via HTTP API"""
        try:
            response = await self.http_client.get("/api/v1/telemetry/current")
            if response.status_code == 200:
                return response.json()
            else:
                raise FirmwareCommunicationException(f"Failed to get telemetry: {response.status_code}")
        except Exception as e:
            logger.error("âŒ Failed to get telemetry: %s", e)
            raise FirmwareCommunicationException(f"Telemetry request failed: {e}")
```

### **Frontend Integration (Báº®T BUá»˜C)**
```python
# WebSocket Service
class WebSocketService:
    def __init__(self):
        self.connections = set()
        self.message_queue = asyncio.Queue()
        
    async def broadcast_telemetry(self, telemetry_data: Dict):
        """Broadcast telemetry data to all connected clients"""
        message = {
            "type": "telemetry",
            "data": telemetry_data,
            "timestamp": datetime.utcnow().isoformat()
        }
        
        await self.broadcast_message(message)
        
    async def broadcast_status(self, status_data: Dict):
        """Broadcast status changes to all connected clients"""
        message = {
            "type": "status_change",
            "data": status_data,
            "timestamp": datetime.utcnow().isoformat()
        }
        
        await self.broadcast_message(message)
        
    async def broadcast_alert(self, alert_data: Dict):
        """Broadcast alerts to all connected clients"""
        message = {
            "type": "alert",
            "data": alert_data,
            "timestamp": datetime.utcnow().isoformat()
        }
        
        await self.broadcast_message(message)
```

---

## ğŸ§ª **TESTING REQUIREMENTS**

### **Testing Standards (Báº®T BUá»˜C)**
```python
# Test Base Class
class BaseTestCase:
    def setUp(self):
        self.app = create_test_app()
        self.client = TestClient(self.app)
        self.db = create_test_database()
        
    async def test_api_performance(self, endpoint: str, method: str = "GET", 
                                  data: Dict = None, max_time: float = 0.1):
        """Test API endpoint performance"""
        start_time = time.time()
        
        if method == "GET":
            response = self.client.get(endpoint)
        elif method == "POST":
            response = self.client.post(endpoint, json=data)
        elif method == "PUT":
            response = self.client.put(endpoint, json=data)
        elif method == "DELETE":
            response = self.client.delete(endpoint)
            
        response_time = time.time() - start_time
        
        self.assertLess(response_time, max_time, 
                       f"Response time {response_time}s exceeds limit {max_time}s")
        self.assertEqual(response.status_code, 200)

# Performance Test
class PerformanceTestCase(BaseTestCase):
    async def test_robot_status_endpoint(self):
        """Test robot status endpoint performance"""
        await self.test_api_performance("/api/v1/robot/status", max_time=0.05)
        
    async def test_telemetry_endpoint(self):
        """Test telemetry endpoint performance"""
        await self.test_api_performance("/api/v1/telemetry/current", max_time=0.05)
        
    async def test_emergency_stop(self):
        """Test emergency stop performance"""
        await self.test_api_performance("/api/v1/safety/emergency", 
                                       method="POST", max_time=0.01)
```

---

## ğŸ“ˆ **MONITORING REQUIREMENTS**

### **Monitoring Implementation (Báº®T BUá»˜C)**
```python
# Monitoring Service
class MonitoringService:
    def __init__(self):
        self.metrics_collector = MetricsCollector()
        self.alert_manager = AlertManager()
        self.health_checker = HealthChecker()
        
    async def start_monitoring(self):
        """Start all monitoring services"""
        # Start metrics collection
        asyncio.create_task(self.metrics_collector.start())
        
        # Start health checks
        asyncio.create_task(self.health_checker.start())
        
        # Start alert monitoring
        asyncio.create_task(self.alert_manager.start())
        
    async def record_system_metrics(self):
        """Record system performance metrics"""
        # CPU usage
        cpu_percent = psutil.cpu_percent(interval=1)
        await self.metrics_collector.record("system.cpu_usage", cpu_percent)
        
        # Memory usage
        memory = psutil.virtual_memory()
        await self.metrics_collector.record("system.memory_usage", memory.percent)
        
        # Disk usage
        disk = psutil.disk_usage('/')
        await self.metrics_collector.record("system.disk_usage", disk.percent)
        
        # Network I/O
        network = psutil.net_io_counters()
        await self.metrics_collector.record("system.network_bytes_sent", network.bytes_sent)
        await self.metrics_collector.record("system.network_bytes_recv", network.bytes_recv)
```

---

## ğŸš€ **DEPLOYMENT REQUIREMENTS**

### **Deployment Standards (Báº®T BUá»˜C)**
```yaml
# Docker Configuration
Dockerfile:
  Base Image: "python:3.11-slim"
  Security: "Non-root user execution"
  Optimization: "Multi-stage build"
  Health Check: "HTTP health endpoint"
  
# Docker Compose
docker-compose.yml:
  Services:
    backend:
      build: "."
      ports: ["8000:8000"]
      environment:
        - ENVIRONMENT=production
        - DATABASE_URL=sqlite:///oht50.db
        - REDIS_URL=redis://redis:6379
      depends_on: ["redis", "database"]
      restart: "unless-stopped"
      
    redis:
      image: "redis:7-alpine"
      ports: ["6379:6379"]
      volumes: ["redis_data:/data"]
      
    database:
      image: "sqlite:latest"
      volumes: ["db_data:/var/lib/sqlite"]
      
# Deployment Script
deploy.sh:
  - "Build Docker images"
  - "Run security scans"
  - "Execute tests"
  - "Deploy to staging"
  - "Run integration tests"
  - "Deploy to production"
  - "Verify deployment"
  - "Setup monitoring"
```

---

## ğŸ“š **DOCUMENTATION REQUIREMENTS**

### **Documentation Standards (Báº®T BUá»˜C)**
```markdown
# API Documentation Template

## Endpoint: GET /api/v1/robot/status

### Description
Get current robot status and telemetry data.

### Performance Requirements
- Response time: < 50ms
- Throughput: 1000+ requests/second
- Availability: > 99.9%

### Request
```http
GET /api/v1/robot/status
Authorization: Bearer <token>
```

### Response
```json
{
  "success": true,
  "data": {
    "robot_id": "OHT-50-001",
    "status": "idle",
    "position": {"x": 150.5, "y": 200.3},
    "battery_level": 87,
    "temperature": 42.5
  },
  "timestamp": "2025-01-28T10:30:00Z"
}
```

### Error Codes
- 401: Unauthorized
- 500: Internal Server Error

### Security
- Authentication required
- Rate limited: 1000 requests/minute
- Audit logged: Yes
```

---

## ğŸ” **QUALITY CONTROL CHECKLIST**

### **Code Review Checklist (MUST PASS)**
```
â–¡ Performance requirements met
â–¡ Security implementation complete
â–¡ Error handling comprehensive
â–¡ Logging vÃ  monitoring added
â–¡ Tests written vÃ  passing
â–¡ Documentation updated
â–¡ Code follows standards
â–¡ Integration tested
â–¡ Performance tested
â–¡ Security scanned
â–¡ Architecture documents read vÃ  understood
â–¡ Firmware integration via HTTP API (NOT RS485)
â–¡ Mock data warnings implemented
â–¡ Real Firmware connection tested
```

### **Deployment Checklist (MUST PASS)**
```
â–¡ All tests passing
â–¡ Performance benchmarks met
â–¡ Security scan clean
â–¡ Documentation complete
â–¡ Monitoring configured
â–¡ Backup systems ready
â–¡ Rollback plan prepared
â–¡ Team notified
â–¡ Stakeholders informed
â–¡ Production ready
â–¡ Real Firmware integration tested
â–¡ No mock data in production code
â–¡ Firmware HTTP API verified
â–¡ Firmware connection validated
```

---

## ğŸš¨ **COMMON MISTAKES TO AVOID**

### **PERFORMANCE MISTAKES**
```
âŒ Ignoring performance requirements
âŒ Not monitoring response times
âŒ Missing database indexes
âŒ Inefficient queries
âŒ No caching strategy
âŒ Blocking operations in async code
```

### **SECURITY MISTAKES**
```
âŒ Missing input validation
âŒ No authentication checks
âŒ Hardcoded secrets
âŒ Missing audit logging
âŒ No rate limiting
âŒ Insecure communication
```

### **INTEGRATION MISTAKES**
```
âŒ Not testing firmware integration
âŒ Missing error handling
âŒ No retry mechanisms
âŒ Inconsistent data formats
âŒ No monitoring for external services
âŒ Missing fallback mechanisms
âŒ Using mock data in production
âŒ Backend trá»±c tiáº¿p giao tiáº¿p RS485 (SAI KIáº¾N TRÃšC)
âŒ KhÃ´ng Ä‘á»c tÃ i liá»‡u kiáº¿n trÃºc trÆ°á»›c khi implement
âŒ KhÃ´ng hiá»ƒu Protocol Gateway architecture
âŒ KhÃ´ng warning vá» mock data usage
```

---

## ğŸ“ **FILE STRUCTURE & NAMING**

### **File Organization**
```
backend/
â”œâ”€â”€ app/
â”‚   â”œâ”€â”€ api/
â”‚   â”‚   â”œâ”€â”€ v1/
â”‚   â”‚   â”‚   â”œâ”€â”€ robot.py
â”‚   â”‚   â”‚   â”œâ”€â”€ telemetry.py
â”‚   â”‚   â”‚   â”œâ”€â”€ safety.py
â”‚   â”‚   â”‚   â””â”€â”€ lidar.py
â”‚   â”‚   â””â”€â”€ websocket.py
â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”œâ”€â”€ robot_control.py
â”‚   â”‚   â”œâ”€â”€ telemetry.py
â”‚   â”‚   â”œâ”€â”€ safety.py
â”‚   â”‚   â””â”€â”€ lidar_processing.py
â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â”œâ”€â”€ robot.py
â”‚   â”‚   â”œâ”€â”€ telemetry.py
â”‚   â”‚   â””â”€â”€ safety.py
â”‚   â””â”€â”€ core/
â”‚       â”œâ”€â”€ security.py
â”‚       â”œâ”€â”€ monitoring.py
â”‚       â””â”€â”€ integration.py
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ unit/
â”‚   â”œâ”€â”€ integration/
â”‚   â””â”€â”€ performance/
â”œâ”€â”€ docs/
â”‚   â”œâ”€â”€ api.md
â”‚   â”œâ”€â”€ deployment.md
â”‚   â””â”€â”€ monitoring.md
â””â”€â”€ docker/
    â”œâ”€â”€ Dockerfile
    â””â”€â”€ docker-compose.yml
```

### **Naming Conventions**
```
- Service files: {service_name}_service.py
- API files: {resource_name}.py
- Model files: {entity_name}.py
- Test files: test_{module_name}.py
- Config files: {environment}.yaml
```

---

## ğŸ¯ **SUCCESS METRICS**

### **Performance Success**
```
âœ… 100% API endpoints meet performance targets
âœ… 100% WebSocket events meet latency requirements
âœ… 100% Database queries meet response time targets
âœ… 0 performance regressions
âœ… 0 critical performance issues
```

### **Security Success**
```
âœ… 100% security requirements implemented
âœ… 0 security vulnerabilities
âœ… 100% authentication/authorization working
âœ… 0 unauthorized access incidents
âœ… 100% audit logging complete
```

### **Integration Success**
```
âœ… 100% firmware integration working
âœ… 100% frontend integration complete
âœ… 100% real-time communication stable
âœ… 0 integration failures
âœ… 100% error recovery working
âœ… 100% real Firmware integration working
âœ… 0 mock data usage in production
âœ… 100% Firmware HTTP API integration
```

---

## ğŸš€ **IMPLEMENTATION GUIDELINES**

### **For Backend Team Lead**
1. **Always prioritize performance vÃ  security**
2. **Review architecture decisions carefully**
3. **Ensure comprehensive testing coverage**
4. **Monitor system performance continuously**
5. **Maintain technical documentation**

### **For Core Developers**
1. **Follow performance requirements strictly**
2. **Implement comprehensive error handling**
3. **Add logging vÃ  monitoring to all services**
4. **Write tests for all functionality**
5. **Document code vÃ  APIs thoroughly**
6. **Äá»ŒC tÃ i liá»‡u kiáº¿n trÃºc trÆ°á»›c khi implement**
7. **Always use real Firmware integration via HTTP API**
8. **Never use mock data in production**
9. **Always warn when using mock data**
10. **KHÃ”NG BAO GIá»œ trá»±c tiáº¿p giao tiáº¿p RS485**
11. **Äá»ƒ Firmware lÃ m Protocol Gateway**

### **For DevOps Engineer**
1. **Automate deployment processes**
2. **Monitor system performance**
3. **Ensure security compliance**
4. **Maintain backup systems**
5. **Optimize infrastructure**

---

**ğŸš¨ REMEMBER: Performance vÃ  Security are NOT optional - they're the foundation of reliable backend systems!**

**Changelog v1.2:**
- âœ… Fixed Architecture Compliance rules (Báº®T BUá»˜C)
- âœ… Added requirement to READ architecture documents
- âœ… Corrected Firmware integration approach (HTTP API, NOT RS485)
- âœ… Updated Integration Standards vá»›i HTTP API examples
- âœ… Fixed Firmware Integration service examples
- âœ… Updated Code Review checklist vá»›i architecture validation
- âœ… Updated Deployment checklist vá»›i Firmware HTTP API validation
- âœ… Updated Core Developers guidelines vá»›i architecture reading requirement
- âœ… Fixed Integration Success metrics cho Firmware HTTP API
- âœ… Added Protocol Gateway architecture diagram

**Changelog v1.1:**
- âœ… Added Hardware & Firmware Integration rules (Báº®T BUá»˜C)
- âœ… Added Mock Data restrictions vÃ  warnings
- âœ… Added Firmware HAL RS485 requirements
- âœ… Updated Code Review checklist vá»›i hardware integration
- âœ… Updated Deployment checklist vá»›i real hardware validation
- âœ… Added Integration Success metrics cho hardware
- âœ… Updated Core Developers guidelines vá»›i hardware requirements

**Changelog v1.0:**
- âœ… Created comprehensive backend development rules
- âœ… Added performance requirements vÃ  monitoring
- âœ… Added security standards vÃ  implementation
- âœ… Added integration requirements
- âœ… Added testing standards
- âœ… Added deployment guidelines
- âœ… Added quality control checklist

**ğŸš¨ LÆ°u Ã½:** Backend team pháº£i tuÃ¢n thá»§ strict performance, security, vÃ  integration standards Ä‘á»ƒ Ä‘áº£m báº£o system reliability vÃ  safety. **KHÃ”NG BAO GIá»œ sá»­ dá»¥ng mock data vá»›i hardware vÃ  firmware trong production!**

**ğŸš¨ KIáº¾N TRÃšC QUAN TRá»ŒNG:** Backend CHá»ˆ giao tiáº¿p vá»›i Firmware qua HTTP/REST API. **KHÃ”NG BAO GIá»œ trá»±c tiáº¿p giao tiáº¿p RS485!** Firmware má»›i lÃ  ngÆ°á»i lÃ m Protocol Gateway vÃ  giao tiáº¿p vá»›i hardware.
