---
description:
globs:
alwaysApply: true
---
# üöÄ BACKEND DEVELOPMENT RULES - OHT-50

**Phi√™n b·∫£n:** 1.0  
**Ng√†y c·∫≠p nh·∫≠t:** 2025-01-28  
**M·ª•c ti√™u:** Chu·∫©n h√≥a quy tr√¨nh ph√°t tri·ªÉn backend cho OHT-50 v·ªõi focus v√†o performance, security v√† integration

---

## üéØ **VAI TR√í & TR√ÅCH NHI·ªÜM**

### **BACKEND TEAM LEAD**
- **Qu·∫£n l√Ω t·ªïng th·ªÉ:** Architecture, performance, security, integration
- **Quality Control:** Review t·∫•t c·∫£ deliverables tr∆∞·ªõc khi approve
- **Coordination:** ƒê·∫£m b·∫£o consistency gi·ªØa c√°c services
- **Technical Leadership:** ƒê·∫£m b·∫£o technical excellence

### **CORE DEVELOPERS**
- **Service Implementation:** Robot Control, Telemetry, Safety, LiDAR Processing
- **API Development:** REST API, WebSocket, Real-time communication
- **Database Design:** SQLite, Redis, Data modeling
- **Integration:** Firmware, Hardware, Frontend integration

### **DEVOPS ENGINEER**
- **Infrastructure:** Docker, CI/CD, Monitoring, Deployment
- **Performance:** Load testing, Optimization, Scaling
- **Security:** Security scanning, Compliance, Hardening
- **Operations:** Backup, Recovery, Maintenance

---

## üö® **CRITICAL REQUIREMENTS (B·∫ÆT BU·ªòC)**

### **1. PERFORMANCE FIRST APPROACH**
```
‚ùå KH√îNG BAO GI·ªú compromise performance cho features
‚úÖ LU√îN LU√îN optimize cho real-time requirements
‚úÖ M·ªñI API endpoint ph·∫£i meet performance targets
‚úÖ TEST performance: API < 50ms, WebSocket < 20ms, DB < 10ms
```

### **2. SECURITY BY DESIGN**
```
BEFORE APPROVAL:
‚ñ° Security review completed
‚ñ° Authentication/Authorization implemented
‚ñ° Data encryption configured
‚ñ° Input validation active
‚ñ° Audit logging enabled
```

### **3. ARCHITECTURE COMPLIANCE (B·∫ÆT BU·ªòC)**
```
MUST FOLLOW ARCHITECTURE DOCUMENTS:
- ƒê·ªåC docs/03-ARCHITECTURE/ TR∆Ø·ªöC KHI IMPLEMENT
- ƒê·ªåC ADR-004-COMMUNICATION_PROTOCOLS.md cho giao ti·∫øp
- ƒê·ªåC ADR-001-SYSTEM_ARCHITECTURE.md cho ki·∫øn tr√∫c t·ªïng th·ªÉ
- ƒê·ªåC ARCHITECTURE_REVIEW_SUMMARY.md cho t·ªïng quan

ARCHITECTURE HI·ªÇU ƒê√öNG:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ         Protocol Gateway            ‚îÇ  ‚Üê FIRMWARE L√ÄM VI·ªÜC N√ÄY
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                  ‚îÇ
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ             ‚îÇ             ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ HTTP  ‚îÇ   ‚îÇWebSocket‚îÇ   ‚îÇ  RS485  ‚îÇ
‚îÇ REST  ‚îÇ   ‚îÇStreaming‚îÇ   ‚îÇ Modbus  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
    ‚îÇ             ‚îÇ             ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇCenter ‚îÇ   ‚îÇFrontend ‚îÇ   ‚îÇHardware ‚îÇ
‚îÇSystem ‚îÇ   ‚îÇ  UI     ‚îÇ   ‚îÇModules  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

BACKEND CH·ªà GIAO TI·∫æP V·ªöI FIRMWARE QUA HTTP/REST API!
BACKEND KH√îNG BAO GI·ªú TR·ª∞C TI·∫æP RS485!
```

### **4. INTEGRATION COMPLIANCE**
```
MUST FOLLOW:
- HTTP/REST API cho Firmware communication
- WebSocket real-time cho frontend communication
- REST API standards cho external integration
- Database schema theo REQ_BE_03
- Security standards theo REQ_BE_04
```

### **5. HARDWARE & FIRMWARE INTEGRATION (B·∫ÆT BU·ªòC)**
```
‚ùå KH√îNG BAO GI·ªú mock data v·ªõi hardware v√† firmware
‚ùå KH√îNG BAO GI·ªú Backend tr·ª±c ti·∫øp giao ti·∫øp RS485
‚úÖ LU√îN LU√îN giao ti·∫øp v·ªõi Firmware qua HTTP/REST API
‚úÖ LU√îN LU√îN ƒë·ªÉ Firmware l√†m Protocol Gateway
‚úÖ PH·∫¢I b√°o r√µ khi s·ª≠ d·ª•ng mock data (ch·ªâ cho development)
‚úÖ PH·∫¢I test v·ªõi Firmware th·∫≠t tr∆∞·ªõc khi deploy

FIRMWARE INTEGRATION RULES:
‚ñ° Backend ch·ªâ giao ti·∫øp v·ªõi Firmware qua HTTP API
‚ñ° Firmware m·ªõi l√† ng∆∞·ªùi giao ti·∫øp RS485 v·ªõi hardware
‚ñ° Backend kh√¥ng bao gi·ªù bi·∫øt v·ªÅ RS485 protocol
‚ñ° Backend ch·ªâ g·ª≠i commands v√† nh·∫≠n data t·ª´ Firmware
‚ñ° Mock data ch·ªâ d√πng cho unit testing Firmware API

MOCK DATA RULES:
‚ñ° Ch·ªâ ƒë∆∞·ª£c d√πng cho unit testing
‚ñ° Ph·∫£i c√≥ flag r√µ r√†ng: use_mock=True
‚ñ° Ph·∫£i log warning khi s·ª≠ d·ª•ng mock
‚ñ° Kh√¥ng ƒë∆∞·ª£c d√πng trong production
‚ñ° Ph·∫£i c√≥ comment gi·∫£i th√≠ch l√Ω do mock
```

---

## üìã **QUY TR√åNH DEVELOPMENT 5 B∆Ø·ªöC (B·∫ÆT BU·ªòC)**

### **B∆Ø·ªöC 1: ARCHITECTURE REVIEW**
```
Backend Team Lead MUST:
‚ñ° ƒê·ªåC docs/03-ARCHITECTURE/ TR∆Ø·ªöC KHI REVIEW
‚ñ° Review service architecture design
‚ñ° Validate performance requirements
‚ñ° Confirm security implementation
‚ñ° Confirm Firmware integration approach (HTTP API, NOT RS485)
‚ñ° Approve technical approach
```

### **B∆Ø·ªöC 2: SERVICE IMPLEMENTATION**
```
Core Developers MUST:
‚ñ° Implement service theo design patterns
‚ñ° Add comprehensive error handling
‚ñ° Implement logging v√† monitoring
‚ñ° Test service functionality
‚ñ° Validate performance metrics
```

### **B∆Ø·ªöC 3: INTEGRATION TESTING**
```
DevOps Engineer MUST:
‚ñ° Test service integration
‚ñ° Validate communication protocols
‚ñ° Test performance under load
‚ñ° Verify security implementation
‚ñ° Test error recovery
```

### **B∆Ø·ªöC 4: QUALITY GATE**
```
Backend Team Lead MUST:
‚ñ° Review complete implementation
‚ñ° Validate performance requirements
‚ñ° Check security compliance
‚ñ° Approve for deployment
‚ñ° Update documentation
```

### **B∆Ø·ªöC 5: DEPLOYMENT & MONITORING**
```
DevOps Engineer MUST:
‚ñ° Deploy to staging environment
‚ñ° Monitor performance metrics
‚ñ° Validate security compliance
‚ñ° Deploy to production
‚ñ° Setup monitoring alerts
```

---

## üèóÔ∏è **ARCHITECTURE STANDARDS**

### **Service Architecture (B·∫ÆT BU·ªòC)**
```python
# Service Base Class
class BaseService:
    def __init__(self):
        self.logger = logging.getLogger(self.__class__.__name__)
        self.metrics = MetricsCollector()
        self.cache = RedisCache()
        
    async def handle_request(self, request: Request) -> Response:
        """Standard request handling with performance monitoring"""
        start_time = time.time()
        try:
            # Validate request
            await self.validate_request(request)
            
            # Process request
            result = await self.process_request(request)
            
            # Log metrics
            self.metrics.record_success(time.time() - start_time)
            
            return Response(success=True, data=result)
            
        except Exception as e:
            self.metrics.record_error(time.time() - start_time, str(e))
            self.logger.error(f"Request failed: {e}")
            raise
```

### **API Standards (B·∫ÆT BU·ªòC)**
```python
# API Response Format
class APIResponse:
    def __init__(self, success: bool, data: Any = None, 
                 message: str = "", error_code: str = None):
        self.success = success
        self.data = data
        self.message = message
        self.error_code = error_code
        self.timestamp = datetime.utcnow().isoformat()
        self.request_id = str(uuid.uuid4())

# Performance Monitoring
class PerformanceMiddleware:
    async def __call__(self, request: Request, call_next):
        start_time = time.time()
        response = await call_next(request)
        process_time = time.time() - start_time
        
        # Record performance metrics
        if process_time > 0.1:  # Log slow requests
            logger.warning(f"Slow request: {request.url} took {process_time}s")
            
        return response
```

---

## üîß **TECHNICAL STANDARDS**

### **Database Standards (B·∫ÆT BU·ªòC)**
```sql
-- Performance optimized schema
CREATE TABLE robot_status (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    robot_id VARCHAR(50) NOT NULL,
    status VARCHAR(20) NOT NULL,
    position_x DECIMAL(10,3),
    position_y DECIMAL(10,3),
    battery_level INTEGER,
    temperature DECIMAL(5,2),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Indexes for performance
CREATE INDEX idx_robot_status_robot_id ON robot_status(robot_id);
CREATE INDEX idx_robot_status_updated ON robot_status(updated_at);
CREATE INDEX idx_robot_status_status ON robot_status(status);
```

### **Security Standards (B·∫ÆT BU·ªòC)**
```python
# Authentication Middleware
class AuthMiddleware:
    def __init__(self, jwt_secret: str):
        self.jwt_secret = jwt_secret
        
    async def authenticate(self, request: Request) -> Optional[User]:
        token = request.headers.get("Authorization")
        if not token or not token.startswith("Bearer "):
            raise HTTPException(status_code=401, detail="Invalid token")
            
        try:
            payload = jwt.decode(token[7:], self.jwt_secret, algorithms=["HS256"])
            return await self.get_user(payload["user_id"])
        except jwt.ExpiredSignatureError:
            raise HTTPException(status_code=401, detail="Token expired")
        except jwt.InvalidTokenError:
            raise HTTPException(status_code=401, detail="Invalid token")

# Input Validation
class InputValidator:
    @staticmethod
    def validate_robot_command(command: Dict) -> bool:
        required_fields = ["command_type", "parameters"]
        if not all(field in command for field in required_fields):
            raise ValueError("Missing required fields")
            
        if command["command_type"] not in ["move", "stop", "pause", "resume"]:
            raise ValueError("Invalid command type")
            
        return True
```

### **Integration Standards (B·∫ÆT BU·ªòC)**
```python
# Firmware Integration Service - MUST USE REAL FIRMWARE
class FirmwareIntegrationService:
    def __init__(self, firmware_url: str = "http://localhost:8081"):
        self.firmware_url = firmware_url
        self.http_client = httpx.AsyncClient(base_url=firmware_url)
        
        # WARNING: This service MUST connect to real Firmware
        # DO NOT use mock data in production
        logger.warning("Firmware Integration: Connecting to REAL Firmware at %s", firmware_url)
        
    async def get_robot_status(self) -> Dict[str, Any]:
        """Get robot status from Firmware via HTTP API"""
        try:
            response = await self.http_client.get("/api/v1/robot/status")
            if response.status_code == 200:
                return response.json()
            else:
                raise FirmwareCommunicationException(f"Failed to get robot status: {response.status_code}")
        except Exception as e:
            logger.error("‚ùå Failed to get robot status: %s", e)
            raise FirmwareCommunicationException(f"Robot status request failed: {e}")
            
    async def send_robot_command(self, command: Dict[str, Any]) -> bool:
        """Send robot command to Firmware via HTTP API"""
        try:
            response = await self.http_client.post("/api/v1/robot/command", json=command)
            if response.status_code == 200:
                result = response.json()
                return result.get("success", False)
            else:
                logger.error("‚ùå Robot command failed: %s", response.status_code)
                return False
        except Exception as e:
            logger.error("‚ùå Failed to send robot command: %s", e)
            return False

# MOCK FIRMWARE SERVICE - FOR DEVELOPMENT ONLY
class MockFirmwareService:
    def __init__(self):
        # WARNING: This is MOCK data - NOT for production use
        logger.warning("üß™ MOCK Firmware Service: Using simulated data - NOT real Firmware!")
        self.mock_data = self._initialize_mock_data()
        
    def _initialize_mock_data(self):
        # MOCK DATA - ONLY FOR UNIT TESTING
        # DO NOT USE IN PRODUCTION
        return {
            "robot_status": {
                "status": "idle",
                "position": {"x": 150.5, "y": 200.3},
                "battery_level": 87,
                "temperature": 42.5
            },
            "telemetry": {
                "motor_speed": 1500,
                "motor_temperature": 45,
                "dock_status": "ready",
                "safety_status": "normal"
            }
        }
```

---

## üìä **PERFORMANCE REQUIREMENTS**

### **Response Time Targets (B·∫ÆT BU·ªòC)**
```yaml
Performance Targets:
  API Endpoints:
    GET /robot/status: "< 50ms"
    POST /robot/control: "< 100ms"
    GET /telemetry/current: "< 50ms"
    POST /safety/emergency: "< 10ms"
    
  WebSocket Events:
    Telemetry updates: "< 20ms"
    Status changes: "< 50ms"
    Alert notifications: "< 100ms"
    
  Database Operations:
    Simple queries: "< 5ms"
    Complex queries: "< 50ms"
    Write operations: "< 10ms"
    
  System Performance:
    CPU usage: "< 60%"
    Memory usage: "< 3GB"
    Network latency: "< 1ms"
    Uptime: "> 99.9%"
```

### **Performance Monitoring (B·∫ÆT BU·ªòC)**
```python
# Performance Monitoring Service
class PerformanceMonitor:
    def __init__(self):
        self.metrics = {}
        self.alerts = []
        
    async def record_metric(self, metric_name: str, value: float, tags: Dict = None):
        """Record performance metric"""
        timestamp = time.time()
        self.metrics[metric_name] = {
            "value": value,
            "timestamp": timestamp,
            "tags": tags or {}
        }
        
        # Check thresholds
        await self.check_thresholds(metric_name, value)
        
    async def check_thresholds(self, metric_name: str, value: float):
        """Check performance thresholds and generate alerts"""
        thresholds = {
            "api_response_time": 100,  # ms
            "websocket_latency": 50,   # ms
            "database_query_time": 10, # ms
            "cpu_usage": 80,           # %
            "memory_usage": 85         # %
        }
        
        if metric_name in thresholds and value > thresholds[metric_name]:
            alert = {
                "metric": metric_name,
                "value": value,
                "threshold": thresholds[metric_name],
                "timestamp": datetime.utcnow().isoformat()
            }
            self.alerts.append(alert)
            await self.send_alert(alert)
```

---

## üîí **SECURITY REQUIREMENTS**

### **Security Implementation (B·∫ÆT BU·ªòC)**
```python
# Security Configuration
SECURITY_CONFIG = {
    "jwt_secret": os.getenv("JWT_SECRET"),
    "jwt_expiry": 3600,  # 1 hour
    "password_min_length": 12,
    "max_login_attempts": 5,
    "lockout_duration": 1800,  # 30 minutes
    "session_timeout": 86400,  # 24 hours
    "rate_limit": {
        "requests_per_minute": 1000,
        "burst_limit": 100
    }
}

# Security Middleware
class SecurityMiddleware:
    def __init__(self):
        self.rate_limiter = RateLimiter()
        self.input_validator = InputValidator()
        
    async def __call__(self, request: Request, call_next):
        # Rate limiting
        if not await self.rate_limiter.check_limit(request):
            raise HTTPException(status_code=429, detail="Rate limit exceeded")
            
        # Input validation
        if request.method in ["POST", "PUT", "PATCH"]:
            await self.input_validator.validate_request(request)
            
        # Security headers
        response = await call_next(request)
        response.headers["X-Content-Type-Options"] = "nosniff"
        response.headers["X-Frame-Options"] = "DENY"
        response.headers["X-XSS-Protection"] = "1; mode=block"
        
        return response
```

---

## üîó **INTEGRATION REQUIREMENTS**

### **Firmware Integration (B·∫ÆT BU·ªòC)**
```python
# Firmware Integration Service - HTTP API ONLY
class FirmwareIntegrationService:
    def __init__(self, firmware_url: str = "http://localhost:8081"):
        self.firmware_url = firmware_url
        self.http_client = httpx.AsyncClient(base_url=firmware_url)
        
    async def get_robot_status(self) -> Dict[str, Any]:
        """Get robot status from Firmware via HTTP API"""
        try:
            response = await self.http_client.get("/api/v1/robot/status")
            if response.status_code == 200:
                return response.json()
            else:
                raise FirmwareCommunicationException(f"Failed to get robot status: {response.status_code}")
        except Exception as e:
            logger.error("‚ùå Failed to get robot status: %s", e)
            raise FirmwareCommunicationException(f"Robot status request failed: {e}")
            
    async def send_robot_command(self, command: Dict[str, Any]) -> bool:
        """Send robot command to Firmware via HTTP API"""
        try:
            # Validate command
            self.validate_command(command)
            
            # Send via HTTP API to Firmware
            response = await self.http_client.post("/api/v1/robot/command", json=command)
            if response.status_code == 200:
                result = response.json()
                success = result.get("success", False)
                
                if success:
                    await self.log_command(command, "success")
                else:
                    await self.log_command(command, "failed")
                    
                return success
            else:
                await self.log_command(command, "error", f"HTTP {response.status_code}")
                return False
                
        except Exception as e:
            await self.log_command(command, "error", str(e))
            raise
            
    async def get_telemetry_data(self) -> Dict[str, Any]:
        """Get telemetry data from Firmware via HTTP API"""
        try:
            response = await self.http_client.get("/api/v1/telemetry/current")
            if response.status_code == 200:
                return response.json()
            else:
                raise FirmwareCommunicationException(f"Failed to get telemetry: {response.status_code}")
        except Exception as e:
            logger.error("‚ùå Failed to get telemetry: %s", e)
            raise FirmwareCommunicationException(f"Telemetry request failed: {e}")
```

### **Frontend Integration (B·∫ÆT BU·ªòC)**
```python
# WebSocket Service
class WebSocketService:
    def __init__(self):
        self.connections = set()
        self.message_queue = asyncio.Queue()
        
    async def broadcast_telemetry(self, telemetry_data: Dict):
        """Broadcast telemetry data to all connected clients"""
        message = {
            "type": "telemetry",
            "data": telemetry_data,
            "timestamp": datetime.utcnow().isoformat()
        }
        
        await self.broadcast_message(message)
        
    async def broadcast_status(self, status_data: Dict):
        """Broadcast status changes to all connected clients"""
        message = {
            "type": "status_change",
            "data": status_data,
            "timestamp": datetime.utcnow().isoformat()
        }
        
        await self.broadcast_message(message)
        
    async def broadcast_alert(self, alert_data: Dict):
        """Broadcast alerts to all connected clients"""
        message = {
            "type": "alert",
            "data": alert_data,
            "timestamp": datetime.utcnow().isoformat()
        }
        
        await self.broadcast_message(message)
```

---

## üß™ **TESTING REQUIREMENTS**

### **Testing Standards (B·∫ÆT BU·ªòC)**
```python
# Test Base Class
class BaseTestCase:
    def setUp(self):
        self.app = create_test_app()
        self.client = TestClient(self.app)
        self.db = create_test_database()
        
    async def test_api_performance(self, endpoint: str, method: str = "GET", 
                                  data: Dict = None, max_time: float = 0.1):
        """Test API endpoint performance"""
        start_time = time.time()
        
        if method == "GET":
            response = self.client.get(endpoint)
        elif method == "POST":
            response = self.client.post(endpoint, json=data)
        elif method == "PUT":
            response = self.client.put(endpoint, json=data)
        elif method == "DELETE":
            response = self.client.delete(endpoint)
            
        response_time = time.time() - start_time
        
        self.assertLess(response_time, max_time, 
                       f"Response time {response_time}s exceeds limit {max_time}s")
        self.assertEqual(response.status_code, 200)

# Performance Test
class PerformanceTestCase(BaseTestCase):
    async def test_robot_status_endpoint(self):
        """Test robot status endpoint performance"""
        await self.test_api_performance("/api/v1/robot/status", max_time=0.05)
        
    async def test_telemetry_endpoint(self):
        """Test telemetry endpoint performance"""
        await self.test_api_performance("/api/v1/telemetry/current", max_time=0.05)
        
    async def test_emergency_stop(self):
        """Test emergency stop performance"""
        await self.test_api_performance("/api/v1/safety/emergency", 
                                       method="POST", max_time=0.01)
```

---

## üìà **MONITORING REQUIREMENTS**

### **Monitoring Implementation (B·∫ÆT BU·ªòC)**
```python
# Monitoring Service
class MonitoringService:
    def __init__(self):
        self.metrics_collector = MetricsCollector()
        self.alert_manager = AlertManager()
        self.health_checker = HealthChecker()
        
    async def start_monitoring(self):
        """Start all monitoring services"""
        # Start metrics collection
        asyncio.create_task(self.metrics_collector.start())
        
        # Start health checks
        asyncio.create_task(self.health_checker.start())
        
        # Start alert monitoring
        asyncio.create_task(self.alert_manager.start())
        
    async def record_system_metrics(self):
        """Record system performance metrics"""
        # CPU usage
        cpu_percent = psutil.cpu_percent(interval=1)
        await self.metrics_collector.record("system.cpu_usage", cpu_percent)
        
        # Memory usage
        memory = psutil.virtual_memory()
        await self.metrics_collector.record("system.memory_usage", memory.percent)
        
        # Disk usage
        disk = psutil.disk_usage('/')
        await self.metrics_collector.record("system.disk_usage", disk.percent)
        
        # Network I/O
        network = psutil.net_io_counters()
        await self.metrics_collector.record("system.network_bytes_sent", network.bytes_sent)
        await self.metrics_collector.record("system.network_bytes_recv", network.bytes_recv)
```

---

## üöÄ **DEPLOYMENT REQUIREMENTS**

### **Deployment Standards (B·∫ÆT BU·ªòC)**
```yaml
# Docker Configuration
Dockerfile:
  Base Image: "python:3.11-slim"
  Security: "Non-root user execution"
  Optimization: "Multi-stage build"
  Health Check: "HTTP health endpoint"
  
# Docker Compose
docker-compose.yml:
  Services:
    backend:
      build: "."
      ports: ["8000:8000"]
      environment:
        - ENVIRONMENT=production
        - DATABASE_URL=sqlite:///oht50.db
        - REDIS_URL=redis://redis:6379
      depends_on: ["redis", "database"]
      restart: "unless-stopped"
      
    redis:
      image: "redis:7-alpine"
      ports: ["6379:6379"]
      volumes: ["redis_data:/data"]
      
    database:
      image: "sqlite:latest"
      volumes: ["db_data:/var/lib/sqlite"]
      
# Deployment Script
deploy.sh:
  - "Build Docker images"
  - "Run security scans"
  - "Execute tests"
  - "Deploy to staging"
  - "Run integration tests"
  - "Deploy to production"
  - "Verify deployment"
  - "Setup monitoring"
```

---

## üìö **DOCUMENTATION REQUIREMENTS**

### **Documentation Standards (B·∫ÆT BU·ªòC)**
```markdown
# API Documentation Template

## Endpoint: GET /api/v1/robot/status

### Description
Get current robot status and telemetry data.

### Performance Requirements
- Response time: < 50ms
- Throughput: 1000+ requests/second
- Availability: > 99.9%

### Request
```http
GET /api/v1/robot/status
Authorization: Bearer <token>
```

### Response
```json
{
  "success": true,
  "data": {
    "robot_id": "OHT-50-001",
    "status": "idle",
    "position": {"x": 150.5, "y": 200.3},
    "battery_level": 87,
    "temperature": 42.5
  },
  "timestamp": "2025-01-28T10:30:00Z"
}
```

### Error Codes
- 401: Unauthorized
- 500: Internal Server Error

### Security
- Authentication required
- Rate limited: 1000 requests/minute
- Audit logged: Yes
```

---

## üîç **QUALITY CONTROL CHECKLIST**

### **Code Review Checklist (MUST PASS)**
```
‚ñ° Performance requirements met
‚ñ° Security implementation complete
‚ñ° Error handling comprehensive
‚ñ° Logging v√† monitoring added
‚ñ° Tests written v√† passing
‚ñ° Documentation updated
‚ñ° Code follows standards
‚ñ° Integration tested
‚ñ° Performance tested
‚ñ° Security scanned
‚ñ° Architecture documents read v√† understood
‚ñ° Firmware integration via HTTP API (NOT RS485)
‚ñ° Mock data warnings implemented
‚ñ° Real Firmware connection tested
```

### **Deployment Checklist (MUST PASS)**
```
‚ñ° All tests passing
‚ñ° Performance benchmarks met
‚ñ° Security scan clean
‚ñ° Documentation complete
‚ñ° Monitoring configured
‚ñ° Backup systems ready
‚ñ° Rollback plan prepared
‚ñ° Team notified
‚ñ° Stakeholders informed
‚ñ° Production ready
‚ñ° Real Firmware integration tested
‚ñ° No mock data in production code
‚ñ° Firmware HTTP API verified
‚ñ° Firmware connection validated
```

---

## üö® **COMMON MISTAKES TO AVOID**

### **PERFORMANCE MISTAKES**
```
‚ùå Ignoring performance requirements
‚ùå Not monitoring response times
‚ùå Missing database indexes
‚ùå Inefficient queries
‚ùå No caching strategy
‚ùå Blocking operations in async code
```

### **SECURITY MISTAKES**
```
‚ùå Missing input validation
‚ùå No authentication checks
‚ùå Hardcoded secrets
‚ùå Missing audit logging
‚ùå No rate limiting
‚ùå Insecure communication
```

### **INTEGRATION MISTAKES**
```
‚ùå Not testing firmware integration
‚ùå Missing error handling
‚ùå No retry mechanisms
‚ùå Inconsistent data formats
‚ùå No monitoring for external services
‚ùå Missing fallback mechanisms
‚ùå Using mock data in production
‚ùå Backend tr·ª±c ti·∫øp giao ti·∫øp RS485 (SAI KI·∫æN TR√öC)
‚ùå Kh√¥ng ƒë·ªçc t√†i li·ªáu ki·∫øn tr√∫c tr∆∞·ªõc khi implement
‚ùå Kh√¥ng hi·ªÉu Protocol Gateway architecture
‚ùå Kh√¥ng warning v·ªÅ mock data usage
```

---

## üìÅ **FILE STRUCTURE & NAMING**

### **File Organization**
```
backend/
‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îú‚îÄ‚îÄ api/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ v1/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ robot.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ telemetry.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ safety.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ lidar.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ websocket.py
‚îÇ   ‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ robot_control.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ telemetry.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ safety.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ lidar_processing.py
‚îÇ   ‚îú‚îÄ‚îÄ models/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ robot.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ telemetry.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ safety.py
‚îÇ   ‚îî‚îÄ‚îÄ core/
‚îÇ       ‚îú‚îÄ‚îÄ security.py
‚îÇ       ‚îú‚îÄ‚îÄ monitoring.py
‚îÇ       ‚îî‚îÄ‚îÄ integration.py
‚îú‚îÄ‚îÄ tests/
‚îÇ   ‚îú‚îÄ‚îÄ unit/
‚îÇ   ‚îú‚îÄ‚îÄ integration/
‚îÇ   ‚îî‚îÄ‚îÄ performance/
‚îú‚îÄ‚îÄ docs/
‚îÇ   ‚îú‚îÄ‚îÄ api.md
‚îÇ   ‚îú‚îÄ‚îÄ deployment.md
‚îÇ   ‚îî‚îÄ‚îÄ monitoring.md
‚îî‚îÄ‚îÄ docker/
    ‚îú‚îÄ‚îÄ Dockerfile
    ‚îî‚îÄ‚îÄ docker-compose.yml
```

### **Naming Conventions**
```
- Service files: {service_name}_service.py
- API files: {resource_name}.py
- Model files: {entity_name}.py
- Test files: test_{module_name}.py
- Config files: {environment}.yaml
```

---

## üéØ **SUCCESS METRICS**

### **Performance Success**
```
‚úÖ 100% API endpoints meet performance targets
‚úÖ 100% WebSocket events meet latency requirements
‚úÖ 100% Database queries meet response time targets
‚úÖ 0 performance regressions
‚úÖ 0 critical performance issues
```

### **Security Success**
```
‚úÖ 100% security requirements implemented
‚úÖ 0 security vulnerabilities
‚úÖ 100% authentication/authorization working
‚úÖ 0 unauthorized access incidents
‚úÖ 100% audit logging complete
```

### **Integration Success**
```
‚úÖ 100% firmware integration working
‚úÖ 100% frontend integration complete
‚úÖ 100% real-time communication stable
‚úÖ 0 integration failures
‚úÖ 100% error recovery working
‚úÖ 100% real Firmware integration working
‚úÖ 0 mock data usage in production
‚úÖ 100% Firmware HTTP API integration
```

---

## üöÄ **IMPLEMENTATION GUIDELINES**

### **For Backend Team Lead**
1. **Always prioritize performance v√† security**
2. **Review architecture decisions carefully**
3. **Ensure comprehensive testing coverage**
4. **Monitor system performance continuously**
5. **Maintain technical documentation**

### **For Core Developers**
1. **Follow performance requirements strictly**
2. **Implement comprehensive error handling**
3. **Add logging v√† monitoring to all services**
4. **Write tests for all functionality**
5. **Document code v√† APIs thoroughly**
6. **ƒê·ªåC t√†i li·ªáu ki·∫øn tr√∫c tr∆∞·ªõc khi implement**
7. **Always use real Firmware integration via HTTP API**
8. **Never use mock data in production**
9. **Always warn when using mock data**
10. **KH√îNG BAO GI·ªú tr·ª±c ti·∫øp giao ti·∫øp RS485**
11. **ƒê·ªÉ Firmware l√†m Protocol Gateway**

### **For DevOps Engineer**
1. **Automate deployment processes**
2. **Monitor system performance**
3. **Ensure security compliance**
4. **Maintain backup systems**
5. **Optimize infrastructure**

---

**üö® REMEMBER: Performance v√† Security are NOT optional - they're the foundation of reliable backend systems!**

**Changelog v1.2:**
- ‚úÖ Fixed Architecture Compliance rules (B·∫ÆT BU·ªòC)
- ‚úÖ Added requirement to READ architecture documents
- ‚úÖ Corrected Firmware integration approach (HTTP API, NOT RS485)
- ‚úÖ Updated Integration Standards v·ªõi HTTP API examples
- ‚úÖ Fixed Firmware Integration service examples
- ‚úÖ Updated Code Review checklist v·ªõi architecture validation
- ‚úÖ Updated Deployment checklist v·ªõi Firmware HTTP API validation
- ‚úÖ Updated Core Developers guidelines v·ªõi architecture reading requirement
- ‚úÖ Fixed Integration Success metrics cho Firmware HTTP API
- ‚úÖ Added Protocol Gateway architecture diagram

**Changelog v1.1:**
- ‚úÖ Added Hardware & Firmware Integration rules (B·∫ÆT BU·ªòC)
- ‚úÖ Added Mock Data restrictions v√† warnings
- ‚úÖ Added Firmware HAL RS485 requirements
- ‚úÖ Updated Code Review checklist v·ªõi hardware integration
- ‚úÖ Updated Deployment checklist v·ªõi real hardware validation
- ‚úÖ Added Integration Success metrics cho hardware
- ‚úÖ Updated Core Developers guidelines v·ªõi hardware requirements

**Changelog v1.0:**
- ‚úÖ Created comprehensive backend development rules
- ‚úÖ Added performance requirements v√† monitoring
- ‚úÖ Added security standards v√† implementation
- ‚úÖ Added integration requirements
- ‚úÖ Added testing standards
- ‚úÖ Added deployment guidelines
- ‚úÖ Added quality control checklist

**üö® L∆∞u √Ω:** Backend team ph·∫£i tu√¢n th·ªß strict performance, security, v√† integration standards ƒë·ªÉ ƒë·∫£m b·∫£o system reliability v√† safety. **KH√îNG BAO GI·ªú s·ª≠ d·ª•ng mock data v·ªõi hardware v√† firmware trong production!**

**üö® KI·∫æN TR√öC QUAN TR·ªåNG:** Backend CH·ªà giao ti·∫øp v·ªõi Firmware qua HTTP/REST API. **KH√îNG BAO GI·ªú tr·ª±c ti·∫øp giao ti·∫øp RS485!** Firmware m·ªõi l√† ng∆∞·ªùi l√†m Protocol Gateway v√† giao ti·∫øp v·ªõi hardware.
